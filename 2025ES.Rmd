```{r}
# ---------------------------------------------------------------
# 描述性統計分析腳本 (R) - [2025-10-28 v3 更新版]
# - 更新 1: 數值型統計(numeric_stats) 將按 Q 編號排序
# - 更新 2: 修正類別型統計(categorical_stats)的 Value 欄位錯誤
# - 更新 3 (本次): 新增 Q31, Q32, Q33 的特殊編碼規則 (我不理解=0)
# ---------------------------------------------------------------

# --- 0. 安裝與載入套件 ---
# install.packages("tidyverse")
# install.packages("janitor")

library(tidyverse) # 用於資料處理 (dplyr, readr, tidyr, stringr)
library(janitor)   # 用於建立次數分配表 (tabyl)

# 設定檔案路徑 (請確保檔案與 R 腳本在同一目錄，或提供完整路徑)
file_path <- "2025 CZ Engagement survey (回覆) 的副本 - 表單回應 1.csv"

# --- 1. 載入資料 ---
tryCatch({
  df_raw <- read_csv(file_path)
  print(paste("成功載入檔案:", file_path))
  print(paste("資料維度:", dim(df_raw)[1], "筆觀察值,", dim(df_raw)[2], "個欄位"))
}, error = function(e) {
  stop(paste("無法讀取檔案，請檢查路徑是否正確:", file_path, "\n錯誤訊息:", e$message))
})


# --- 2. 建立 Codebook 並重命名欄位 ---
original_names <- colnames(df_raw)
new_names <- paste0("Q", 1:length(original_names))

codebook <- tibble(
  New_Column = new_names,
  Original_Column = original_names
)

df_renamed <- df_raw
colnames(df_renamed) <- new_names

print("已建立欄位對照表 (Codebook)，變數 'codebook' 可供查閱。")
# write_csv(codebook, "codebook.csv")


# --- 3. 自動分類與清理欄位 ---

# 定義自動分類的規則 (Heuristics)
LIKERT_PATTERN <- "^\\s*\\d+\\s*-.+" # 偵測 "數字 - 文字" 格式
MIN_AVG_LEN_FOR_QUALITATIVE <- 50  # 質性欄位的最小平均字串長度
MAX_UNIQUE_FOR_CATEGORICAL <- 15 # 類別欄位允許的最大唯一值數量

# --- [更新 3] ---
# 建立一個清單，存放需要特殊編碼 (含 "我不理解") 的欄位
special_recode_cols <- c("Q31", "Q32", "Q33")

# 準備用來存放分類結果的向量
likert_text_cols <- c()       # 標準 Likert 欄位 ("4 - 同意")
custom_likert_cols <- c()     # [新] 自訂 Likert 欄位 (Q31-Q33)
qualitative_cols <- c()       # 質性欄位 (長文字，將被忽略)
numeric_cols_pre <- c()       # 原始就是數值的欄位
categorical_cols_pre <- c()   # 原始就是文字的類別欄位

# 遍歷所有欄位進行分類
for (col in new_names) {
  if (all(is.na(df_renamed[[col]]))) next
  
  col_type <- class(df_renamed[[col]])
  
  if (col_type %in% c("numeric", "integer", "double")) {
    # 類型 1: 原始就是數值
    numeric_cols_pre <- c(numeric_cols_pre, col)
    
  } else if (col_type == "character") {
    # 類型 2: 原始是文字
    first_val <- first(na.omit(df_renamed[[col]]))
    
    # --- [更新 3] 優先檢查是否為特殊編碼欄位 ---
    if (col %in% special_recode_cols) {
      custom_likert_cols <- c(custom_likert_cols, col)
      
    } else if (!is.na(first_val) && str_detect(first_val, LIKERT_PATTERN)) {
      # 類型 2a: 是標準 Likert 量表 ("4 - 同意")
      likert_text_cols <- c(likert_text_cols, col)
      
    } else {
      # 類型 2b/2c: 檢查是類別型還是質性
      avg_len <- mean(nchar(df_renamed[[col]]), na.rm = TRUE)
      n_unique <- n_distinct(df_renamed[[col]], na.rm = TRUE)
      
      if (avg_len > MIN_AVG_LEN_FOR_QUALITATIVE || n_unique > MAX_UNIQUE_FOR_CATEGORICAL) {
        # 類型 2b: 質性欄位
        qualitative_cols <- c(qualitative_cols, col)
      } else {
        # 類型 2c: 類別型欄位 (例如 "我的組別")
        categorical_cols_pre <- c(categorical_cols_pre, col)
      }
    }
  }
}

print("欄位分類完成 (已加入 Q31-Q33 特殊規則)。")

# --- 4. 執行資料清理 (轉換 Likert 欄位) ---

df_cleaned <- df_renamed %>%
  # (A) 處理標準 Likert 欄位 (抓開頭數字)
  mutate(across(all_of(likert_text_cols), 
                ~as.numeric(str_extract(.x, "^\\s*\\d+")))) %>%
  
  # --- [更新 3] (B) 處理 Q31-Q33 特殊編碼欄位 ---
  mutate(across(all_of(custom_likert_cols),
                ~case_when(
                  str_detect(.x, "^4") ~ 4, # 4 - 非常同意
                  str_detect(.x, "^3") ~ 3, # 3 - 同意
                  str_detect(.x, "^2") ~ 2, # 2 - 不同意
                  str_detect(.x, "^1") ~ 1, # 1 - 非常不同意
                  str_detect(.x, "我不理解") ~ 0, # [新規則]
                  TRUE ~ NA_real_ # 其他 (例如 NA)
                )))

print("Likert 量表欄位已轉換為數值 (含 Q31-Q33)。")

# --- 5. 執行描述性統計 (數值型/評分型欄位) ---

# --- [更新 3] 最終的數值欄位 = 原始數值 + 標準 Likert + 自訂 Likert ---
numeric_analysis_cols <- c(numeric_cols_pre, likert_text_cols, custom_likert_cols)
numeric_analysis_cols <- setdiff(numeric_analysis_cols, "Q1") # 排除 Q1 (時間戳記)

# 計算描述性統計
numeric_stats <- df_cleaned %>%
  select(all_of(numeric_analysis_cols)) %>%
  summarise(
    across(
      everything(),
      list(
        N = ~sum(!is.na(.)),
        Mean = ~mean(.x, na.rm = TRUE),
        SD = ~sd(.x, na.rm = TRUE),
        Median = ~median(.x, na.rm = TRUE),
        Min = ~min(.x, na.rm = TRUE),
        Max = ~max(.x, na.rm = TRUE)
      ),
      .names = "{.col}___{.fn}" # 使用 ___ 作為分隔符
    )
  ) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Metric",
    values_to = "Value"
  ) %>%
  separate(Metric, into = c("New_Column", "Statistic"), sep = "___") %>%
  pivot_wider(
    names_from = Statistic,
    values_from = Value
  ) %>%
  left_join(codebook, by = "New_Column") %>%
  select(New_Column, Original_Column, N, Mean, SD, Median, Min, Max) %>%
  mutate(
    Mean = ifelse(is.nan(Mean), NA, Mean),
    SD = ifelse(is.nan(SD), NA, SD)
  ) %>%
  # 排序 (按 Q 編號)
  mutate(sort_key = as.numeric(str_replace(New_Column, "Q", ""))) %>%
  arrange(sort_key) %>%
  select(-sort_key)

print("--- NTumeric/Likert Stats) [已按 Q 編號排序, 含 Q31-Q33] ---")
print(numeric_stats, n = Inf) 

print("數值型統計已儲存至變數 'numeric_stats'")
write_csv(numeric_stats, "numeric_descriptive_stats.csv")


# --- 6. 執行描述性統計 (類別型欄位) ---

# [更新 3] Q31-Q33 已被移除，這裡不需更動
categorical_analysis_cols <- categorical_cols_pre

categorical_stats <- map_dfr(categorical_analysis_cols, ~{
  df_cleaned %>%
    tabyl(.data[[.x]]) %>%
    mutate(New_Column = .x) %>%
    rename(Value = 1) # [修正]
}, .id = NULL) %>%
  rename(Frequency = n, Percentage = percent) %>%
  left_join(codebook, by = "New_Column") %>%
  select(New_Column, Original_Column, Value, Frequency, Percentage) %>%
  arrange(New_Column, desc(Frequency))%>%
  mutate(sort_key = as.numeric(str_replace(New_Column, "Q", ""))) %>%
  arrange(sort_key) %>%
  select(-sort_key)

print("--- 類別型欄位次數分配 (Categorical Stats) ---")
print(categorical_stats, n = Inf)

print("類別型統計已儲存至變數 'categorical_stats'")
write_csv(categorical_stats, "categorical_descriptive_stats.csv")

print("--- 分析完成 ---")
```
```{r}
# --- 5. 執行「分群」描述性統計 ---

# (A) 定義要分析的數值欄位
numeric_analysis_cols <- c(numeric_cols_pre, likert_text_cols, custom_likert_cols)
numeric_analysis_cols <- setdiff(numeric_analysis_cols, "Q1") # 排除 Q1 (時間戳記)

# (B) 定義您要納入分析的組別
# Q2 = 我的組別
target_groups <- c("領導發展", "營運發展", "教學發展", "影響力發展", "聯盟發展")

# (C) 執行分群計算
grouped_numeric_stats <- df_cleaned %>%
  # (C.1) 篩選出您指定的組別
  filter(Q2 %in% target_groups) %>%
  
  # (C.2) 依據 Q2 (組別) 進行分組
  group_by(Q2) %>%
  
  # (C.3) 對所有數值欄位進行彙總
  summarise(
    across(
      all_of(numeric_analysis_cols),
      list(
        N = ~sum(!is.na(.)),
        Mean = ~mean(.x, na.rm = TRUE),
        SD = ~sd(.x, na.rm = TRUE),
        Median = ~median(.x, na.rm = TRUE),
        Min = ~min(.x, na.rm = TRUE),
        Max = ~max(.x, na.rm = TRUE)
      ),
      .names = "{.col}___{.fn}"
    ),
    .groups = "drop" # 計算完畢後解除分組
  ) %>%
  
  # (C.4) 轉換為長表格 (方便閱讀與後續處理)
  pivot_longer(
    cols = -Q2, # 排除 Q2 (組別) 欄
    names_to = "Metric",
    values_to = "Value"
  ) %>%
  separate(Metric, into = c("New_Column", "Statistic"), sep = "___") %>%
  
  # (C.5) 轉回寬表格 (N, Mean, SD... 變回欄位)
  pivot_wider(
    names_from = Statistic,
    values_from = Value
  ) %>%
  
  # (C.6) 整理結果
  left_join(codebook, by = "New_Column") %>%
  mutate(
    Mean = ifelse(is.nan(Mean), NA, Mean),
    SD = ifelse(is.nan(SD), NA, SD)
  ) %>%
  
  # (C.7) 排序：先按組別，再按 Q 編號
  mutate(sort_key = as.numeric(str_replace(New_Column, "Q", ""))) %>%
  arrange(Q2, sort_key) %>%
  
  # (C.8) 最終欄位排序
  select(Q2, New_Column, Original_Column, N, Mean, SD, Median, Min, Max, -sort_key)

print("--- 依組別 (Q2) 分群之描述性統計 ---")
print(grouped_numeric_stats, n = Inf)

# 提示：儲存這個分群結果
print("分群統計已儲存至變數 'grouped_numeric_stats'")
write_csv(grouped_numeric_stats, "grouped_numeric_stats.csv")

print("--- 分群分析完成 ---")
```
```{r}
# --- 5. 執行「分群」描述性統計 (依 Q4 年資) ---
# ---------------------------------------------------------------
# 分群描述性統計 (R) - 依「總工作年資」(Q4)
#
# 目的: 
# 1. 執行完整的資料清理 (同主腳本)
# 2. 篩選出特定的四個年資組別
# 3. 依年資計算所有數值型/評分型題目的描述性統計
# ---------------------------------------------------------------

# --- 0. 載入套件 ---
library(tidyverse)
library(stringr)

# --- 1. 載入資料 ---
file_path <- "2025 CZ Engagement survey (回覆) 的副本 - 表單回應 1.csv"
tryCatch({
  df_raw <- read_csv(file_path)
  print(paste("成功載入檔案:", file_path))
}, error = function(e) {
  stop(paste("無法讀取檔案:", e$message))
})

# --- 2. 建立 Codebook 並重命名欄位 ---
original_names <- colnames(df_raw)
new_names <- paste0("Q", 1:length(original_names))
codebook <- tibble(
  New_Column = new_names,
  Original_Column = original_names
)
df_renamed <- df_raw
colnames(df_renamed) <- new_names

# --- 3. 欄位分類 (與主腳本相同) ---
LIKERT_PATTERN <- "^\\s*\\d+\\s*-.+"
special_recode_cols <- c("Q31", "Q32", "Q33") # Q31-Q33 特殊編碼

likert_text_cols <- c()
custom_likert_cols <- c()
numeric_cols_pre <- c()
# (此腳本暫不處理類別型或質性)

for (col in new_names) {
  if (all(is.na(df_renamed[[col]]))) next
  col_type <- class(df_renamed[[col]])
  
  if (col_type %in% c("numeric", "integer", "double")) {
    numeric_cols_pre <- c(numeric_cols_pre, col)
  } else if (col_type == "character") {
    first_val <- first(na.omit(df_renamed[[col]]))
    
    if (col %in% special_recode_cols) {
      custom_likert_cols <- c(custom_likert_cols, col)
    } else if (!is.na(first_val) && str_detect(first_val, LIKERT_PATTERN)) {
      likert_text_cols <- c(likert_text_cols, col)
    }
  }
}
print("欄位分類完成。")

# --- 4. 執行資料清理 (與主腳本相同) ---
df_cleaned <- df_renamed %>%
  # (A) 處理標準 Likert
  mutate(across(all_of(likert_text_cols), 
                ~as.numeric(str_extract(.x, "^\\s*\\d+")))) %>%
  # (B) 處理 Q31-Q33 特殊編碼
  mutate(across(all_of(custom_likert_cols),
                ~case_when(
                  str_detect(.x, "^4") ~ 4,
                  str_detect(.x, "^3") ~ 3,
                  str_detect(.x, "^2") ~ 2,
                  str_detect(.x, "^1") ~ 1,
                  str_detect(.x, "我不理解") ~ 0,
                  TRUE ~ NA_real_
                )))
print("資料清理完成。")

# --- 5. 執行「分群」描述性統計 (依 Q4 年資) ---

# (A) 定義要分析的數值欄位
numeric_analysis_cols <- c(numeric_cols_pre, likert_text_cols, custom_likert_cols)
numeric_analysis_cols <- setdiff(numeric_analysis_cols, "Q1") # 排除 Q1 (時間戳記)

# (B) 定義您要納入分析的年資組別
# Q4 = 我在 誠致 的總工作年資
target_seniority_groups <- c("1 年以下", "1-2 年", "2-3 年", "3 年以上")

# (C) 執行分群計算
grouped_numeric_stats_by_seniority <- df_cleaned %>%
  # (C.1) 篩選出您指定的組別
  filter(Q4 %in% target_seniority_groups) %>%
  
  # (C.2) 依據 Q4 (年資) 進行分組
  group_by(Q4) %>%
  
  # (C.3) 對所有數值欄位進行彙總
  summarise(
    across(
      all_of(numeric_analysis_cols),
      list(
        N = ~sum(!is.na(.)),
        Mean = ~mean(.x, na.rm = TRUE),
        SD = ~sd(.x, na.rm = TRUE),
        Median = ~median(.x, na.rm = TRUE),
        Min = ~min(.x, na.rm = TRUE),
        Max = ~max(.x, na.rm = TRUE)
      ),
      .names = "{.col}___{.fn}"
    ),
    .groups = "drop" # 計算完畢後解除分組
  ) %>%
  
  # (C.4) 轉換為長表格 (方便閱讀與後續處理)
  pivot_longer(
    cols = -Q4, # 排除 Q4 (年資) 欄
    names_to = "Metric",
    values_to = "Value"
  ) %>%
  separate(Metric, into = c("New_Column", "Statistic"), sep = "___") %>%
  
  # (C.5) 轉回寬表格 (N, Mean, SD... 變回欄位)
  pivot_wider(
    names_from = Statistic,
    values_from = Value
  ) %>%
  
  # (C.6) 整理結果
  left_join(codebook, by = "New_Column") %>%
  mutate(
    Mean = ifelse(is.nan(Mean), NA, Mean),
    SD = ifelse(is.nan(SD), NA, SD)
  ) %>%
  
  # (C.7) 排序：先按年資，再按 Q 編號
  # (可選) 讓年資有固定順序
  mutate(Q4 = factor(Q4, levels = target_seniority_groups)) %>% 
  mutate(sort_key = as.numeric(str_replace(New_Column, "Q", ""))) %>%
  arrange(Q4, sort_key) %>%
  
  # (C.8) 最終欄位排序
  select(Q4, New_Column, Original_Column, N, Mean, SD, Median, Min, Max, -sort_key)

print("--- 依總工作年資 (Q4) 分群之描述性統計 ---")
print(grouped_numeric_stats_by_seniority, n = Inf)

# 提示：儲存這個分群結果
print("分群統計已儲存至變數 'grouped_numeric_stats_by_seniority'")
write_csv(grouped_numeric_stats_by_seniority, "grouped_numeric_stats_by_Q4.csv")

print("--- 分群分析完成 ---")

